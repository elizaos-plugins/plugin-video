{"version":3,"sources":["../src/services/video.ts","../src/index.ts"],"sourcesContent":["import ffmpeg from \"fluent-ffmpeg\";\nimport fs from \"fs\";\nimport { tmpdir } from \"os\";\nimport path from \"path\";\nimport youtubeDl from \"youtube-dl-exec\";\n\nexport class VideoService {\n    static serviceType = \"VIDEO\";\n    private cacheKey = \"content/video\";\n    private dataDir = \"./content_cache\";\n\n    private queue: string[] = [];\n    private processing = false;\n\n    constructor() {\n        this.ensureDataDirectoryExists();\n    }\n\n    static getInstance(): VideoService {\n        return new VideoService();\n    }\n\n    getInstance() {\n        return VideoService.getInstance();\n    }\n\n    async initialize(_runtime: any): Promise<void> {}\n\n    private ensureDataDirectoryExists() {\n        if (!fs.existsSync(this.dataDir)) {\n            fs.mkdirSync(this.dataDir);\n        }\n    }\n\n    public isVideoUrl(url: string): boolean {\n        return (\n            url.includes(\"youtube.com\") ||\n            url.includes(\"youtu.be\") ||\n            url.includes(\"vimeo.com\")\n        );\n    }\n\n    public async downloadMedia(url: string): Promise<string> {\n        const videoId = this.getVideoId(url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(url, {\n                verbose: true,\n                output: outputFile,\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            throw new Error(\"Failed to download media\");\n        }\n    }\n\n    public async downloadVideo(videoInfo: any): Promise<string> {\n        const videoId = this.getVideoId(videoInfo.webpage_url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(videoInfo.webpage_url, {\n                verbose: true,\n                output: outputFile,\n                format: \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best\",\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            throw new Error(\"Failed to download video\");\n        }\n    }\n\n    public async processVideo(\n        url: string,\n        runtime: any\n    ): Promise<any> {\n        this.queue.push(url);\n        this.processQueue(runtime);\n\n        return new Promise((resolve, reject) => {\n            const checkQueue = async () => {\n                const index = this.queue.indexOf(url);\n                if (index !== -1) {\n                    setTimeout(checkQueue, 100);\n                } else {\n                    try {\n                        const result = await this.processVideoFromUrl(\n                            url,\n                            runtime\n                        );\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            checkQueue();\n        });\n    }\n\n    private async processQueue(runtime: any): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const url = this.queue.shift()!;\n            await this.processVideoFromUrl(url, runtime);\n        }\n\n        this.processing = false;\n    }\n\n    private async processVideoFromUrl(\n        url: string,\n        runtime: any\n    ): Promise<any> {\n        const videoId =\n            url.match(\n                /(?:youtu\\.be\\/|youtube\\.com(?:\\/embed\\/|\\/v\\/|\\/watch\\?v=|\\/watch\\?.+&v=))([^\\/&?]+)/ // eslint-disable-line\n            )?.[1] || \"\";\n        const videoUuid = this.getVideoId(videoId);\n        const cacheKey = `${this.cacheKey}/${videoUuid}`;\n\n        const cached = await runtime.cacheManager.get(cacheKey);\n\n        if (cached) {\n            return cached;\n        }\n\n        const videoInfo = await this.fetchVideoInfo(url);\n        const transcript = await this.getTranscript(url, videoInfo, runtime);\n\n        const result: any = {\n            id: videoUuid,\n            url: url,\n            title: videoInfo.title,\n            source: videoInfo.channel,\n            description: videoInfo.description,\n            text: transcript,\n        };\n\n        await runtime.cacheManager.set(cacheKey, result);\n\n        return result;\n    }\n\n    private getVideoId(url: string): string {\n        // Simple hash function instead of stringToUuid\n        let hash = 0;\n        for (let i = 0; i < url.length; i++) {\n            const char = url.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash;\n        }\n        return Math.abs(hash).toString(36);\n    }\n\n    async fetchVideoInfo(url: string): Promise<any> {\n        if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n            try {\n                const response = await fetch(url);\n                if (response.ok) {\n                    // If the URL is a direct link to an MP4 file, return a simplified video info object\n                    return {\n                        title: path.basename(url),\n                        description: \"\",\n                        channel: \"\",\n                    };\n                }\n            } catch (error) {\n                // Fall back to using youtube-dl if direct download fails\n            }\n        }\n\n        try {\n            const result = await youtubeDl(url, {\n                dumpJson: true,\n                verbose: true,\n                callHome: false,\n                noCheckCertificates: true,\n                preferFreeFormats: true,\n                youtubeSkipDashManifest: true,\n                writeSub: true,\n                writeAutoSub: true,\n                subLang: \"en\",\n                skipDownload: true,\n            });\n            return result;\n        } catch (error) {\n            throw new Error(\"Failed to fetch video information\");\n        }\n    }\n\n    private async getTranscript(\n        url: string,\n        videoInfo: any,\n        runtime: any\n    ): Promise<string> {\n        try {\n            // Check for manual subtitles\n            if (videoInfo.subtitles && videoInfo.subtitles.en) {\n                const srtContent = await this.downloadSRT(\n                    videoInfo.subtitles.en[0].url\n                );\n                return this.parseSRT(srtContent);\n            }\n\n            // Check for automatic captions\n            if (\n                videoInfo.automatic_captions &&\n                videoInfo.automatic_captions.en\n            ) {\n                const captionUrl = videoInfo.automatic_captions.en[0].url;\n                const captionContent = await this.downloadCaption(captionUrl);\n                return this.parseCaption(captionContent);\n            }\n\n            // Check if it's a music video\n            if (\n                videoInfo.categories &&\n                videoInfo.categories.includes(\"Music\")\n            ) {\n                return \"No lyrics available.\";\n            }\n\n            // Fall back to audio transcription\n            return this.transcribeAudio(url, runtime);\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    private async downloadCaption(url: string): Promise<string> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\n                `Failed to download caption: ${response.statusText}`\n            );\n        }\n        return await response.text();\n    }\n\n    private parseCaption(captionContent: string): string {\n        try {\n            const jsonContent = JSON.parse(captionContent);\n            if (jsonContent.events) {\n                return jsonContent.events\n                    .filter((event: any) => event.segs)\n                    .map((event: any) => event.segs.map((seg: any) => seg.utf8).join(\"\"))\n                    .join(\"\")\n                    .replace(\"\\n\", \" \");\n            } else {\n                return \"Error: Unable to parse captions\";\n            }\n        } catch (error) {\n            return \"Error: Unable to parse captions\";\n        }\n    }\n\n    private parseSRT(srtContent: string): string {\n        // Simple SRT parser (replace with a more robust solution if needed)\n        return srtContent\n            .split(\"\\n\\n\")\n            .map((block) => block.split(\"\\n\").slice(2).join(\" \"))\n            .join(\" \");\n    }\n\n    private async downloadSRT(url: string): Promise<string> {\n        const response = await fetch(url);\n        return await response.text();\n    }\n\n    async transcribeAudio(\n        url: string,\n        runtime: any\n    ): Promise<string> {\n        const mp4FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp4`\n        );\n\n        const mp3FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp3`\n        );\n\n        if (!fs.existsSync(mp3FilePath)) {\n            if (fs.existsSync(mp4FilePath)) {\n                await this.convertMp4ToMp3(mp4FilePath, mp3FilePath);\n            } else {\n                await this.downloadAudio(url, mp3FilePath);\n            }\n        }\n\n        const audioBuffer = fs.readFileSync(mp3FilePath);\n        const startTime = Date.now();\n        const transcriptionService = runtime.getService(\n            'TRANSCRIPTION'\n        );\n\n        if (!transcriptionService) {\n            throw new Error(\"Transcription service not found\");\n        }\n\n        const uintBuffer = new Uint8Array(audioBuffer).buffer;\n        const transcript = await transcriptionService.transcribe(uintBuffer);\n\n        // Don't delete the MP3 file as it might be needed for future use\n        return transcript || \"Transcription failed\";\n    }\n\n    private async convertMp4ToMp3(\n        inputPath: string,\n        outputPath: string\n    ): Promise<void> {\n        return new Promise((resolve, reject) => {\n            ffmpeg(inputPath)\n                .output(outputPath)\n                .noVideo()\n                .audioCodec(\"libmp3lame\")\n                .on(\"end\", () => {\n                    resolve();\n                })\n                .on(\"error\", (err: any) => {\n                    reject(err);\n                })\n                .run();\n        });\n    }\n\n    private async downloadAudio(\n        url: string,\n        outputFile: string\n    ): Promise<string> {\n        outputFile =\n            outputFile ??\n            path.join(this.dataDir, `${this.getVideoId(url)}.mp3`);\n\n        try {\n            if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n                const tempMp4File = path.join(\n                    tmpdir(),\n                    `${this.getVideoId(url)}.mp4`\n                );\n                const response = await fetch(url);\n                const arrayBuffer = await response.arrayBuffer();\n                const buffer = Buffer.from(arrayBuffer);\n                fs.writeFileSync(tempMp4File, buffer);\n\n                await new Promise<void>((resolve, reject) => {\n                    ffmpeg(tempMp4File)\n                        .output(outputFile)\n                        .noVideo()\n                        .audioCodec(\"libmp3lame\")\n                        .on(\"end\", () => {\n                            fs.unlinkSync(tempMp4File);\n                            resolve();\n                        })\n                        .on(\"error\", (err: any) => {\n                            reject(err);\n                        })\n                        .run();\n                });\n            } else {\n                await youtubeDl(url, {\n                    verbose: true,\n                    extractAudio: true,\n                    audioFormat: \"mp3\",\n                    output: outputFile,\n                    writeInfoJson: true,\n                });\n            }\n            return outputFile;\n        } catch (error) {\n            throw new Error(\"Failed to download audio\");\n        }\n    }\n}\n","import {\n    VideoService,\n} from \"./services/video\";\n\n\nconst browserPlugin = {\n  name: \"default\",\n  description: \"Default plugin, with basic actions and evaluators\",\n  services: [new VideoService()],\n  actions: [],\n};\n\nexport default browserPlugin;"],"mappings":"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","names":[]}