{"version":3,"sources":["../src/services/video.ts","../src/index.ts"],"sourcesContent":["import {\n    type IAgentRuntime,\n    type ITranscriptionService,\n    type IVideoService,\n    type Media,\n    Service,\n    ServiceType,\n    stringToUuid,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport ffmpeg from \"fluent-ffmpeg\";\nimport fs from \"fs\";\nimport { tmpdir } from \"os\";\nimport path from \"path\";\nimport youtubeDl from \"youtube-dl-exec\";\n\nexport class VideoService extends Service implements IVideoService {\n    static serviceType: ServiceType = ServiceType.VIDEO;\n    private cacheKey = \"content/video\";\n    private dataDir = \"./content_cache\";\n\n    private queue: string[] = [];\n    private processing = false;\n\n    constructor() {\n        super();\n        this.ensureDataDirectoryExists();\n    }\n\n    getInstance(): IVideoService {\n        return VideoService.getInstance();\n    }\n\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\n\n    private ensureDataDirectoryExists() {\n        if (!fs.existsSync(this.dataDir)) {\n            fs.mkdirSync(this.dataDir);\n        }\n    }\n\n    public isVideoUrl(url: string): boolean {\n        return (\n            url.includes(\"youtube.com\") ||\n            url.includes(\"youtu.be\") ||\n            url.includes(\"vimeo.com\")\n        );\n    }\n\n    public async downloadMedia(url: string): Promise<string> {\n        const videoId = this.getVideoId(url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(url, {\n                verbose: true,\n                output: outputFile,\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            elizaLogger.log(\"Error downloading media:\", error);\n            throw new Error(\"Failed to download media\");\n        }\n    }\n\n    public async downloadVideo(videoInfo: any): Promise<string> {\n        const videoId = this.getVideoId(videoInfo.webpage_url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(videoInfo.webpage_url, {\n                verbose: true,\n                output: outputFile,\n                format: \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best\",\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            elizaLogger.log(\"Error downloading video:\", error);\n            throw new Error(\"Failed to download video\");\n        }\n    }\n\n    public async processVideo(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<Media> {\n        this.queue.push(url);\n        this.processQueue(runtime);\n\n        return new Promise((resolve, reject) => {\n            const checkQueue = async () => {\n                const index = this.queue.indexOf(url);\n                if (index !== -1) {\n                    setTimeout(checkQueue, 100);\n                } else {\n                    try {\n                        const result = await this.processVideoFromUrl(\n                            url,\n                            runtime\n                        );\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            checkQueue();\n        });\n    }\n\n    private async processQueue(runtime): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const url = this.queue.shift()!;\n            await this.processVideoFromUrl(url, runtime);\n        }\n\n        this.processing = false;\n    }\n\n    private async processVideoFromUrl(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<Media> {\n        const videoId =\n            url.match(\n                /(?:youtu\\.be\\/|youtube\\.com(?:\\/embed\\/|\\/v\\/|\\/watch\\?v=|\\/watch\\?.+&v=))([^\\/&?]+)/ // eslint-disable-line\n            )?.[1] || \"\";\n        const videoUuid = this.getVideoId(videoId);\n        const cacheKey = `${this.cacheKey}/${videoUuid}`;\n\n        const cached = await runtime.cacheManager.get<Media>(cacheKey);\n\n        if (cached) {\n            elizaLogger.log(\"Returning cached video file\");\n            return cached;\n        }\n\n        elizaLogger.log(\"Cache miss, processing video\");\n        elizaLogger.log(\"Fetching video info\");\n        const videoInfo = await this.fetchVideoInfo(url);\n        elizaLogger.log(\"Getting transcript\");\n        const transcript = await this.getTranscript(url, videoInfo, runtime);\n\n        const result: Media = {\n            id: videoUuid,\n            url: url,\n            title: videoInfo.title,\n            source: videoInfo.channel,\n            description: videoInfo.description,\n            text: transcript,\n        };\n\n        await runtime.cacheManager.set(cacheKey, result);\n\n        return result;\n    }\n\n    private getVideoId(url: string): string {\n        return stringToUuid(url);\n    }\n\n    async fetchVideoInfo(url: string): Promise<any> {\n        if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n            try {\n                const response = await fetch(url);\n                if (response.ok) {\n                    // If the URL is a direct link to an MP4 file, return a simplified video info object\n                    return {\n                        title: path.basename(url),\n                        description: \"\",\n                        channel: \"\",\n                    };\n                }\n            } catch (error) {\n                elizaLogger.log(\"Error downloading MP4 file:\", error);\n                // Fall back to using youtube-dl if direct download fails\n            }\n        }\n\n        try {\n            const result = await youtubeDl(url, {\n                dumpJson: true,\n                verbose: true,\n                callHome: false,\n                noCheckCertificates: true,\n                preferFreeFormats: true,\n                youtubeSkipDashManifest: true,\n                writeSub: true,\n                writeAutoSub: true,\n                subLang: \"en\",\n                skipDownload: true,\n            });\n            return result;\n        } catch (error) {\n            elizaLogger.log(\"Error fetching video info:\", error);\n            throw new Error(\"Failed to fetch video information\");\n        }\n    }\n\n    private async getTranscript(\n        url: string,\n        videoInfo: any,\n        runtime: IAgentRuntime\n    ): Promise<string> {\n        elizaLogger.log(\"Getting transcript\");\n        try {\n            // Check for manual subtitles\n            if (videoInfo.subtitles && videoInfo.subtitles.en) {\n                elizaLogger.log(\"Manual subtitles found\");\n                const srtContent = await this.downloadSRT(\n                    videoInfo.subtitles.en[0].url\n                );\n                return this.parseSRT(srtContent);\n            }\n\n            // Check for automatic captions\n            if (\n                videoInfo.automatic_captions &&\n                videoInfo.automatic_captions.en\n            ) {\n                elizaLogger.log(\"Automatic captions found\");\n                const captionUrl = videoInfo.automatic_captions.en[0].url;\n                const captionContent = await this.downloadCaption(captionUrl);\n                return this.parseCaption(captionContent);\n            }\n\n            // Check if it's a music video\n            if (\n                videoInfo.categories &&\n                videoInfo.categories.includes(\"Music\")\n            ) {\n                elizaLogger.log(\"Music video detected, no lyrics available\");\n                return \"No lyrics available.\";\n            }\n\n            // Fall back to audio transcription\n            elizaLogger.log(\n                \"No subtitles or captions found, falling back to audio transcription\"\n            );\n            return this.transcribeAudio(url, runtime);\n        } catch (error) {\n            elizaLogger.log(\"Error in getTranscript:\", error);\n            throw error;\n        }\n    }\n\n    private async downloadCaption(url: string): Promise<string> {\n        elizaLogger.log(\"Downloading caption from:\", url);\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\n                `Failed to download caption: ${response.statusText}`\n            );\n        }\n        return await response.text();\n    }\n\n    private parseCaption(captionContent: string): string {\n        elizaLogger.log(\"Parsing caption\");\n        try {\n            const jsonContent = JSON.parse(captionContent);\n            if (jsonContent.events) {\n                return jsonContent.events\n                    .filter((event) => event.segs)\n                    .map((event) => event.segs.map((seg) => seg.utf8).join(\"\"))\n                    .join(\"\")\n                    .replace(\"\\n\", \" \");\n            } else {\n                elizaLogger.log(\"Unexpected caption format:\", jsonContent);\n                return \"Error: Unable to parse captions\";\n            }\n        } catch (error) {\n            elizaLogger.log(\"Error parsing caption:\", error);\n            return \"Error: Unable to parse captions\";\n        }\n    }\n\n    private parseSRT(srtContent: string): string {\n        // Simple SRT parser (replace with a more robust solution if needed)\n        return srtContent\n            .split(\"\\n\\n\")\n            .map((block) => block.split(\"\\n\").slice(2).join(\" \"))\n            .join(\" \");\n    }\n\n    private async downloadSRT(url: string): Promise<string> {\n        elizaLogger.log(\"downloadSRT\");\n        const response = await fetch(url);\n        return await response.text();\n    }\n\n    async transcribeAudio(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<string> {\n        elizaLogger.log(\"Preparing audio for transcription...\");\n        const mp4FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp4`\n        );\n\n        const mp3FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp3`\n        );\n\n        if (!fs.existsSync(mp3FilePath)) {\n            if (fs.existsSync(mp4FilePath)) {\n                elizaLogger.log(\"MP4 file found. Converting to MP3...\");\n                await this.convertMp4ToMp3(mp4FilePath, mp3FilePath);\n            } else {\n                elizaLogger.log(\"Downloading audio...\");\n                await this.downloadAudio(url, mp3FilePath);\n            }\n        }\n\n        elizaLogger.log(`Audio prepared at ${mp3FilePath}`);\n\n        const audioBuffer = fs.readFileSync(mp3FilePath);\n        elizaLogger.log(`Audio file size: ${audioBuffer.length} bytes`);\n\n        elizaLogger.log(\"Starting transcription...\");\n        const startTime = Date.now();\n        const transcriptionService = runtime.getService<ITranscriptionService>(\n            ServiceType.TRANSCRIPTION\n        );\n\n        if (!transcriptionService) {\n            throw new Error(\"Transcription service not found\");\n        }\n\n        const uintBuffer = new Uint8Array(audioBuffer).buffer;\n        const transcript = await transcriptionService.transcribe(uintBuffer);\n\n        const endTime = Date.now();\n        elizaLogger.log(\n            `Transcription completed in ${(endTime - startTime) / 1000} seconds`\n        );\n\n        // Don't delete the MP3 file as it might be needed for future use\n        return transcript || \"Transcription failed\";\n    }\n\n    private async convertMp4ToMp3(\n        inputPath: string,\n        outputPath: string\n    ): Promise<void> {\n        return new Promise((resolve, reject) => {\n            ffmpeg(inputPath)\n                .output(outputPath)\n                .noVideo()\n                .audioCodec(\"libmp3lame\")\n                .on(\"end\", () => {\n                    elizaLogger.log(\"Conversion to MP3 complete\");\n                    resolve();\n                })\n                .on(\"error\", (err) => {\n                    elizaLogger.log(\"Error converting to MP3:\", err);\n                    reject(err);\n                })\n                .run();\n        });\n    }\n\n    private async downloadAudio(\n        url: string,\n        outputFile: string\n    ): Promise<string> {\n        elizaLogger.log(\"Downloading audio\");\n        outputFile =\n            outputFile ??\n            path.join(this.dataDir, `${this.getVideoId(url)}.mp3`);\n\n        try {\n            if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n                elizaLogger.log(\n                    \"Direct MP4 file detected, downloading and converting to MP3\"\n                );\n                const tempMp4File = path.join(\n                    tmpdir(),\n                    `${this.getVideoId(url)}.mp4`\n                );\n                const response = await fetch(url);\n                const arrayBuffer = await response.arrayBuffer();\n                const buffer = Buffer.from(arrayBuffer);\n                fs.writeFileSync(tempMp4File, buffer);\n\n                await new Promise<void>((resolve, reject) => {\n                    ffmpeg(tempMp4File)\n                        .output(outputFile)\n                        .noVideo()\n                        .audioCodec(\"libmp3lame\")\n                        .on(\"end\", () => {\n                            fs.unlinkSync(tempMp4File);\n                            resolve();\n                        })\n                        .on(\"error\", (err) => {\n                            reject(err);\n                        })\n                        .run();\n                });\n            } else {\n                elizaLogger.log(\n                    \"YouTube video detected, downloading audio with youtube-dl\"\n                );\n                await youtubeDl(url, {\n                    verbose: true,\n                    extractAudio: true,\n                    audioFormat: \"mp3\",\n                    output: outputFile,\n                    writeInfoJson: true,\n                });\n            }\n            return outputFile;\n        } catch (error) {\n            elizaLogger.log(\"Error downloading audio:\", error);\n            throw new Error(\"Failed to download audio\");\n        }\n    }\n}\n","import {\n    VideoService,\n} from \"./services/video\";\n\n\nconst browserPlugin = {\n  name: \"default\",\n  description: \"Default plugin, with basic actions and evaluators\",\n  services: [new VideoService() as any],\n  actions: [],\n};\n\nexport default browserPlugin;"],"mappings":"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","names":[]}